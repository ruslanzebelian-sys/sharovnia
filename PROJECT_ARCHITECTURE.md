# PROJECT_ARCHITECTURE

Проект: **Kolhoz Billiard Calculator**

## 1. Обзор архитектуры верхнего уровня

Проект использует слоистую frontend-first архитектуру, в которой каждая фича изолируется в отдельный сервисный модуль. UI-слой остается тонким, бизнес-логика остается чистой, а сервисы можно позднее вынести в API или микросервисы без переписывания ядра.

### Слой UI
Назначение: рендерить экраны, собирать ввод пользователя, отображать состояние и обратную связь.

Состав:
- страницы Next.js App Router (`app/*`)
- презентационные React-компоненты (`components/*`, `modules/*`)
- стили Tailwind

Правила:
- В React-компонентах не должно быть формул подсчета очков, правил хода и логики штрафов.
- UI вызывает только функции прикладного (application/use-case) слоя.

### Прикладной слой
Назначение: оркестрировать пользовательские сценарии и координировать сервисные модули.

Состав:
- функции use-case (создание игры, отправка удара, применение фола, завершение игры)
- преобразование между UI-моделями и доменными моделями
- координация состояния клиентского store

Правила:
- Слой может зависеть от domain и services.
- В слое не должно быть кода рендера, зависящего от фреймворка.

### Доменный слой
Назначение: хранить канонические игровые модели и инварианты.

Состав:
- доменные сущности (`Game`, `Player`, `Turn`, `Shot`, `Penalty`)
- value-objects (`BallPrice`, `ScoreDelta`, `Timestamp`)
- доменные ограничения и общие типы

Правила:
- Только TypeScript без привязки к фреймворку.
- Без I/O и UI-зависимостей.

### Сервисный слой
Назначение: хранить изолированную фичевую логику в виде независимых сервисных модулей.

Состав:
- `game-engine-service`
- `scoring-service`
- `penalty-resolution-service`
- `turn-manager-service`
- позже: `export-service`, `stats-service`, `history-service`

Правила:
- По умолчанию используются только чистые функции.
- Входы и выходы должны быть явными.
- Нельзя использовать React, DOM и прямые мутации store.

### Инфраструктурный слой (готовность к будущему)
Назначение: подключать внешние системы при добавлении backend и realtime.

Состав (в будущем):
- API-клиенты (REST/GraphQL)
- realtime-адаптеры (WebSocket/SSE)
- адаптеры хранения (local storage, server DB)
- обертки наблюдаемости и логирования

Правила:
- Инфраструктура должна быть заменяемой.
- Domain/services не должны зависеть от конкретной реализации транспорта и хранения.

---

## 2. Структура папок (полное дерево)

```text
/app
  /api                             # Будущие route handlers (опционально позже)
  /(routes)
    /page.tsx                      # Стартовая страница / настройка стола
    /game/page.tsx                 # Экран активной игры
  /layout.tsx
  /globals.css

/components
  /ui                              # Переиспользуемые UI-примитивы (Button, Input, Card)
  /shared                          # Общие универсальные компоненты

/modules
  /table-setup                     # UI-композиция фичи настройки стола
  /game-board                      # UI-композиция фичи активной игры
  /scoreboard                      # UI-композиция фичи панели счета

/services
  /game-engine-service
    index.ts
    types.ts
    service.ts
    __tests__/service.test.ts
  /scoring-service
    index.ts
    types.ts
    service.ts
    __tests__/service.test.ts
  /penalty-resolution-service
    index.ts
    types.ts
    service.ts
    __tests__/service.test.ts
  /turn-manager-service
    index.ts
    types.ts
    service.ts
    __tests__/service.test.ts
  /export-service                  # В будущем: экспорт игровых логов

/domain
  /entities
    game.ts
    player.ts
    turn.ts
  /value-objects
    score.ts
    ball-price.ts
  /rules
    invariants.ts

/types
  game.ts                          # Общие типы на границах приложения
  service-contracts.ts             # Контракты между сервисами

/store
  game-store.ts                    # Клиентский контейнер состояния (например, Zustand/Redux позже)
  selectors.ts
  actions.ts

/lib
  time.ts                          # Утилиты времени
  math.ts                          # Детерминированные математические функции
  guards.ts                        # Runtime-проверки и type guards

/tests
  /unit
  /integration

/docs
  PROJECT_ARCHITECTURE.md
```

### Ответственность папок

- `app`: только точки входа маршрутов и композиция на уровне страниц.
- `components`: переиспользуемые презентационные элементы без бизнес-правил.
- `modules`: UI-композиция фич из components и вызовов application-слоя.
- `services`: изолированные бизнес-возможности, одна фича на папку сервиса.
- `domain`: ядро игровой модели, инварианты и доменный словарь.
- `types`: общие контракты, которые используются между слоями.
- `store`: клиентское управление состоянием и набор selectors/actions.
- `lib`: общие утилиты без состояния, не привязанные к одной фиче.
- `tests`: централизованные тестовые наборы для контроля качества.
- `docs`: архитектурные и инженерные стандарты.

---

## 3. Стандарт сервисного модуля

Каждый сервис фичи должен использовать строгий шаблон:

```text
/services/<feature-name>-service
  index.ts
  types.ts
  service.ts
  __tests__/service.test.ts
```

### Обязательные файлы

- `types.ts`: типы входа/выхода и сервис-специфичные типы.
- `service.ts`: чистые бизнес-функции; при одинаковом вводе дают одинаковый результат.
- `index.ts`: только публичные экспорты (без логики).

### Обязательные правила

- Только чистые функции.
- Без импортов `React`.
- Без DOM API (`window`, `document`, `HTMLElement` и т.д.).
- Без прямого глобального изменяемого состояния.
- Без сетевых вызовов внутри core-функций.
- Явные типизированные контракты входа/выхода.
- Для невалидных доменных состояний: `throw` или typed error object.

### Минимальный шаблон

```ts
// types.ts
export type ApplyScoreInput = {
  currentScore: number;
  points: number;
};

export type ApplyScoreOutput = {
  nextScore: number;
};

// service.ts
import type { ApplyScoreInput, ApplyScoreOutput } from "./types";

export function applyScore(input: ApplyScoreInput): ApplyScoreOutput {
  return { nextScore: input.currentScore + input.points };
}

// index.ts
export * from "./types";
export * from "./service";
```

---

## 4. Базовые сервисы для первой реализации

### 4.1 game-engine-service
Ответственность: оркестровать жизненный цикл игры и контролировать общий поток.

Зона ответственности:
- инициализация игры из setup-конфига
- применение пайплайна событий удара/хода
- проверка условий завершения игры

Примеры входов:
- `CreateGameConfig`
- `ApplyEventInput`

Примеры выходов:
- `GameState`
- `GameEngineResult` с примененными изменениями и ошибками

### 4.2 scoring-service
Ответственность: вычислять изменения счета для валидных действий.

Зона ответственности:
- логика множителя цены шара
- вычисление положительных и отрицательных очков
- итоги раунда и накопительные итоги

Ограничение:
- Сервис должен быть полностью детерминированным и без побочных эффектов.

### 4.3 penalty-resolution-service
Ответственность: обрабатывать фолы/штрафы и преобразовывать их в последствия для счета и хода.

Зона ответственности:
- сопоставление типов штрафов
- расчет штрафных очков
- взаимодействие с переходом хода

Контракт:
- Принимает текущий контекст и событие штрафа, возвращает объект разрешения штрафа.

### 4.4 turn-manager-service
Ответственность: определять активного игрока и переходы хода.

Зона ответственности:
- начальный порядок ходов
- следующий ход после успеха/ошибки/фола
- обработка пропуска и дисквалификации (в будущем)

Контракт:
- Вход: текущее состояние хода и результат события
- Выход: обновленное состояние хода с id активного игрока

---

## 5. Правила зависимостей (критично)

Разрешенное направление:
- `UI -> Application -> Services/Domain -> Types/Lib`

Запрещенное направление:
- `Services -> UI`
- `Domain -> React/Next`
- `Services -> Infrastructure concrete implementations`

Итог:
- Внутренние слои не должны знать о внешних.
- UI-фреймворк и транспорт должны заменяться без переписывания бизнес-сервисов.

---

## 6. Стратегия управления состоянием (frontend-first)

Начальная фаза (без backend):
- Хранить каноническое состояние `GameState` в памяти в `/store`.
- UI отправляет типизированные действия.
- Application-слой преобразует действия в вызовы сервисов.
- Сервисы возвращают новые неизменяемые фрагменты состояния.

Будущая фаза:
- Те же действия можно зеркалировать в API/realtime-адаптеры.
- Логику core-сервисов менять не потребуется.

---

## 7. Стратегия тестирования

- Unit-тесты на каждый сервис (`__tests__/service.test.ts`) для ключевых правил.
- Проверки свойств для scoring и penalties (много пограничных случаев).
- Integration-тесты для прикладных сценариев.
- UI-тесты проверяют рендер и взаимодействие, а не бизнес-формулы.

Критерии качества:
- Каждый фикс бага должен начинаться с падающего теста.
- Критичные сервисы должны иметь высокий coverage ветвлений.

---

## 8. Путь миграции к API и Realtime

Когда добавляется backend:
- Контракты сервисов сохраняются без изменений.
- Добавляются инфраструктурные адаптеры в `/lib` или `/infrastructure`.
- Оркестрация переносится в route handlers или внешний API-сервис.
- По возможности переиспользуется та же domain/service логика на сервере.

Поддержка realtime:
- Определяются контракты событий (`GameEvent`, `GamePatch`).
- Выходы turn-сервиса становятся кандидатами для broadcast payload.
- Store подписывается на socket/SSE adapter без изменения внутренних сервисов.

---

## 9. Чеклист реализации

- [ ] Определить базовые доменные типы в `/domain` и `/types`.
- [ ] Создать 4 базовых сервиса по стандартному шаблону.
- [ ] Связать use-case сценарии между UI и сервисами.
- [ ] Добавить unit-тесты для каждого сервиса.
- [ ] Держать page/components свободными от бизнес-формул.
- [ ] Подготовить адаптеры для будущего API/realtime без изменения сервисных контрактов.

Эта архитектура обеспечивает независимое развитие фич, удобное тестирование и готовность к последующему выделению сервисов в микросервисную модель.
